import React from "react";
import PropTypes from "prop-types";
export var Encoding;
(function (Encoding) {
    Encoding["mjpeg"] = "mjpeg";
    Encoding["ros"] = "ros_compressed";
    Encoding["png"] = "png";
    Encoding["vp8"] = "vp8";
    Encoding["h264"] = "h264";
})(Encoding || (Encoding = {}));
export var TransportLayer;
(function (TransportLayer) {
    TransportLayer["raw"] = "raw";
    TransportLayer["compressed"] = "compressed";
    TransportLayer["theora"] = "theora";
})(TransportLayer || (TransportLayer = {}));
export function rosImageSrcString(topic, height, width, host, port, encoding, transportLayer, quality, bitrate, qmin, qmax, gop, vp8Quality) {
    if (height === void 0) { height = 480; }
    if (width === void 0) { width = 640; }
    if (host === void 0) { host = "http://localhost"; }
    if (port === void 0) { port = 8080; }
    if (encoding === void 0) { encoding = Encoding.mjpeg; }
    if (transportLayer === void 0) { transportLayer = TransportLayer.raw; }
    if (quality === void 0) { quality = 95; }
    if (bitrate === void 0) { bitrate = 100000; }
    if (qmin === void 0) { qmin = 10; }
    if (qmax === void 0) { qmax = 42; }
    if (gop === void 0) { gop = 250; }
    if (vp8Quality === void 0) { vp8Quality = 'realtime'; }
    if (encoding === Encoding.mjpeg) {
        return getMjpegSourceString(topic, height, width, host, port, encoding, transportLayer, quality);
    }
    else if (encoding === Encoding.vp8) {
        return getVp8SourceString(topic, height, width, host, port, encoding, transportLayer, bitrate, qmin, qmax, gop, vp8Quality);
    }
    else {
        return getOtherSourceString(topic, height, width, host, port, encoding, transportLayer);
    }
}
function getMjpegSourceString(topic, height, width, host, port, encoding, transportLayer, quality) {
    if (height === void 0) { height = 480; }
    if (width === void 0) { width = 640; }
    if (host === void 0) { host = "http://localhost"; }
    if (port === void 0) { port = 8080; }
    if (encoding === void 0) { encoding = Encoding.mjpeg; }
    if (transportLayer === void 0) { transportLayer = TransportLayer.raw; }
    if (quality === void 0) { quality = 95; }
    return "".concat(host, ":").concat(port, "/stream?topic=").concat(topic, "&type=").concat(encoding, "&default_transport=").concat(transportLayer, "&width=").concat(width, "&height=").concat(height, "&quality=").concat(quality);
}
function getVp8SourceString(topic, height, width, host, port, encoding, transportLayer, bitrate, qmin, qmax, gop, vp8Quality) {
    return "".concat(host, ":").concat(port, "/stream?topic=").concat(topic, "&type=").concat(encoding, "&default_transport=").concat(transportLayer, "&width=").concat(width, "&height=").concat(height, "&bitrate=").concat(bitrate, "&qmin=").concat(qmin, "&qmax=").concat(qmax, "&gop=").concat(gop, "&quality=").concat(vp8Quality);
}
function getOtherSourceString(topic, height, width, host, port, encoding, transportLayer) {
    return "".concat(host, ":").concat(port, "/stream?topic=").concat(topic, "&type=").concat(encoding, "&default_transport=").concat(transportLayer, "&width=").concat(width, "&height=").concat(height);
}
var defaultImageStyle = {
    maxWidth: "100%",
    height: "auto",
};
export var ImageViewer = function (props) {
    var style = props.imageStyle || ((props.containerWidth && props.containerHeight) ? {} : defaultImageStyle);
    if (props.disabled) {
        return (React.createElement("img", { src: "", alt: "", style: style }));
    }
    else {
        var src = rosImageSrcString(props.topic, props.height, props.width, props.host, props.port, props.encoding, props.transportLayer, props.quality, props.bitrate, props.qmin, props.qmax, props.gop, props.vp8Quality);
        return (React.createElement("img", { src: src, width: props.containerWidth, height: props.containerHeight, alt: "", style: style }));
    }
};
ImageViewer.propTypes = {
    topic: PropTypes.string.isRequired,
    height: PropTypes.number,
    width: PropTypes.number,
    containerWidth: PropTypes.number,
    containerHeight: PropTypes.number,
    host: PropTypes.string,
    port: PropTypes.number,
    encoding: PropTypes.string,
    transportLayer: PropTypes.string,
    quality: PropTypes.number,
    disabled: PropTypes.bool,
    bitrate: PropTypes.number,
    qmin: PropTypes.number,
    qmax: PropTypes.number,
    gop: PropTypes.number,
    vp8Quality: PropTypes.string,
    imageStyle: PropTypes.object,
};
//# sourceMappingURL=ImageViewer.js.map