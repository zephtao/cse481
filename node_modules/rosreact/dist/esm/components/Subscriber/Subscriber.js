var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import PropTypes from 'prop-types';
import React, { createContext, useEffect, useState } from 'react';
import { Message } from 'roslib';
import { useCheckedContext } from '../common';
import { useRos } from '../RosConnection';
import { subscribe, unsubscribe } from './getTopic';
var MessageContext = createContext(new Message({}));
export var Subscriber = function (props) {
    var ros = useRos();
    var _a = useState(new Message(props.messageInitialValue)), message = _a[0], setMessage = _a[1];
    var topic = props.topic, messageType = props.messageType, throttleRate = props.throttleRate, latch = props.latch, queueLength = props.queueLength, queueSize = props.queueSize, customCallback = props.customCallback, other = __rest(props, ["topic", "messageType", "throttleRate", "latch", "queueLength", "queueSize", "customCallback"]);
    var topicSettings = {
        topic: topic,
        messageType: messageType,
        throttleRate: throttleRate,
        latch: latch,
        queueLength: queueLength,
        queueSize: queueSize
    };
    var callback = customCallback || (function (newMessage) { setMessage(newMessage); });
    useEffect(function () {
        var topic = subscribe(ros, topicSettings, callback);
        return function () {
            unsubscribe(topic, callback);
        };
    }, []);
    return (React.createElement(MessageContext.Provider, { value: message }, props.children));
};
Subscriber.propTypes = {
    children: PropTypes.node,
    topic: PropTypes.string.isRequired,
    messageType: PropTypes.string.isRequired,
    throttleRate: PropTypes.number,
    latch: PropTypes.bool,
    queueLength: PropTypes.number,
    queueSize: PropTypes.number,
    messageInitialValue: PropTypes.object,
};
export function useMsg() {
    return useCheckedContext(MessageContext);
}
//# sourceMappingURL=Subscriber.js.map