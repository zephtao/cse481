import React, { Fragment, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useRos } from '../RosConnection';
import { Service, ServiceRequest } from 'roslib';
export var ServiceCaller = function (props) {
    var name = props.name, serviceType = props.serviceType, trigger = props.trigger, request = props.request, callback = props.callback, failedCallback = props.failedCallback;
    var ros = useRos();
    useEffect(function () {
        if (trigger) {
            callService(ros, name, serviceType, request, callback, failedCallback);
        }
    }, [trigger]);
    return React.createElement(Fragment, null);
};
ServiceCaller.propTypes = {
    name: PropTypes.string.isRequired,
    serviceType: PropTypes.string,
    trigger: PropTypes.bool,
    request: PropTypes.object,
    callback: PropTypes.func,
    failedCallback: PropTypes.func,
};
function respCb(resp) { }
export function callService(ros, name, serviceType, request, callback, failedCallback) {
    if (callback === void 0) { callback = (respCb); }
    // ServiceRequest just runs Object.assign under the hood, no reason to template as TReq
    // Just need to take in TReq and pass to ServiceRequest
    var service = new Service({ ros: ros, name: name, serviceType: serviceType });
    var serviceRequest = new ServiceRequest(request);
    service.callService(serviceRequest, callback, failedCallback);
}
//# sourceMappingURL=ServiceCaller.js.map