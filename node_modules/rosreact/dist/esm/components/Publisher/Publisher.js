var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useState, Fragment } from "react";
import PropTypes from "prop-types";
import { useRos } from "../RosConnection";
import { getTopic } from "../Subscriber";
export var Publisher = function (props) {
    var ros = useRos();
    var _a = useState(false), publisherTimer = _a[0], setPublisherTimer = _a[1];
    var topic = props.topic, messageType = props.messageType, throttleRate = props.throttleRate, latch = props.latch, queueLength = props.queueLength, queueSize = props.queueSize, otherProps = __rest(props, ["topic", "messageType", "throttleRate", "latch", "queueLength", "queueSize"]);
    var topicSettings = {
        topic: topic,
        messageType: messageType,
        throttleRate: throttleRate,
        latch: latch,
        queueLength: queueLength,
        queueSize: queueSize
    };
    var publisher = getTopic(ros, topicSettings);
    if (props.autoRepeat) {
        var rate = throttleRate || 1;
        var period_1 = Math.round(1000 / rate);
        useEffect(function () {
            var timer = setTimeout(function () {
                publisher.publish(props.message);
                setPublisherTimer(!publisherTimer);
            }, period_1);
            return function () { clearTimeout(timer); };
        }, [publisherTimer]);
    }
    else {
        useEffect(function () {
            publisher.publish(props.message);
        }, [props.message]);
    }
    useEffect(function () {
        return function () {
            publisher.unadvertise();
        };
    }, []);
    return React.createElement(Fragment, null);
};
Publisher.propTypes = {
    topic: PropTypes.string.isRequired,
    message: PropTypes.object,
    messageType: PropTypes.string.isRequired,
    throttleRate: PropTypes.number,
    latch: PropTypes.bool,
    queueLength: PropTypes.number,
    queueSize: PropTypes.number,
    autoRepeat: PropTypes.bool,
};
//# sourceMappingURL=Publisher.js.map